<div id="start-test"></div>
<div id="log-info"></div>
<script type="text/javascript">
    // there are really two suites of tests, one for the Culture Adaptation assay and one for the
    // Drug Selection assay.  Both of these assays are implemnted by the tracking assay but have different
    // code behind them (depending on whether they are adaptation or selection).
    var _tests = [
        // Culture Adaptation
        {name: 'Day0Configs', fn: testDay0Configs},
        {name: 'Day0Objects', fn: testDay0Objects},
        {name: 'InvalidDay0UploadNoFlasks', fn: testInvalidDay0UploadNoFlasks},
        {name: 'InvalidDay0UploadZeroFlasks', fn: testInvalidDay0UploadZeroFlasks},
        {name: 'Day0Upload1', fn: testDay0Upload1},
        {name: 'Day0Upload2', fn: testDay0Upload2},
        {name: 'Day0Results', fn: testDay0Results},
        {name: 'DailyConfigs', fn: testDailyConfigs},
        {name: 'DailyObjects', fn: testDailyObjects},
        {name: 'InvalidDailyUploadNoResults', fn: testInvalidDailyUploadNoResults},
        {name: 'InvalidDailyUploadBadExperiment', fn: testInvalidDailyUploadExperiment},
        {name: 'TrackingRunDataPatient1', fn: testTrackingRunDataPatient1},
        {name: 'InvalidDailyUploadTooManyFlasks', fn: testInvalidDailyUploadTooManyFlasks},
        {name: 'InvalidDailyUploadInvalidFlask', fn: testInvalidDailyUploadInvalidFlask},
        {name: 'InvalidDailyUploadZeroParasitemia', fn: testInvalidDailyUploadZeroParasitemia},
        {name: 'DailyUpload1', fn: testDailyUpload1},
        {name: 'InvalidDailyUploadMeasurementExists', fn: testInvalidDailyUploadMeasurementExists},
        {name: 'DailyUpload2', fn: testDailyUpload2},
        {name: 'TrackingRunDataAll', fn: testTrackingRunDataAll},
        {name: 'MultiExperiementUpload', fn: testMultiExperimentUpload},
        {name: 'TrackingRunDataPatient2', fn: testTrackingRunDataPatient2},
        {name: 'DailyUpload5', fn: testDailyUpload5},
        {name: 'DailyUpload6', fn: testDailyUpload6},
        {name: 'MaintenanceStopped', fn: testMaintenanceStopped},
        {name: 'CalculatedResults', fn: testCalculatedResults},
        {name: 'GenericFoldIncrease', fn: testFoldIncreaseCalculator},
        {name: 'GenericNumDays', fn: testNumDaysCalculator},
        // Drug Selection
        {name: 'SwitchToSelection', fn: switchToSelection},
        {name: 'Day0Configs', fn: testDay0Configs},
        {name: 'Day0Objects', fn: testDay0Objects},
        {name: 'SelectionCompounds', fn: testCompounds},
        {name: 'Day0Upload1', fn: testDay0Upload1},
        {name: 'Day0Upload2', fn: testDay0Upload2},
        {name: 'Day0Results', fn: testDay0Results},
        {name: 'TrackingRunDataPatient1', fn: testTrackingRunDataPatient1},
        {name: 'InvalidDailyUploadZeroParasitemia', fn: testInvalidDailyUploadZeroParasitemia},
        {name: 'DailyUpload1', fn: testDailyUpload1},
        {name: 'InvalidDailyUploadMeasurementExists', fn: testInvalidDailyUploadMeasurementExists},
        {name: 'DailyUpload2', fn: testDailyUpload2},
        {name: 'TrackingRunDataAll', fn: testTrackingRunDataAll},
        {name: 'MultiExperimentUpload', fn: testMultiExperimentUpload},
        {name: 'TrackingRunDataPatient2', fn: testTrackingRunDataPatient2},
        {name: 'DailyUpload5', fn: testDailyUpload5},
        {name: 'DailyUpload6', fn: testDailyUpload6},
        {name: 'DailyUpload7', fn: testDailyUpload7},
        {name: 'DailyUpload8', fn: testDailyUpload8},
        {name: 'MaintenanceStopped', fn: testMaintenanceStopped},
        {name: 'CalculatedResults', fn: testCalculatedResults},
        {name: 'GenericFoldIncrease', fn: testFoldIncreaseCalculator},
        {name: 'GenericFirstDayPositive', fn: testFirstDayPositiveCalculator}
        //{name: 'BulkUpload', fn: testBulkUpload}
    ];

    // messages output to the console
    var _successMessage = "Generations to come will sing of your good deeds.";
    var _failureMessage = "What was the number of that truck driving school again?";
    var _doneMessage = "DONE: "; // signal that the test the test is done
    var _logHtml = "";
    var _assayId;
    var _assayName;
    var _bulkCounter;
    var _bulkLimit = 203;

    // expected results for tracking assay (shared between culture adaptatio and drug selection)
    var _expectedRunFields = ['PatientID', 'StartDate','ExperimentID'];
    var _expectedDailyFields = ['SampleID', 'MeasurementDate', 'Scientist', 'Stage', 'Parasitemia', 'Gametocytemia',
        'Removed', 'RBCBatchID', 'SerumBatchID', 'AlbumaxBatchID','GrowthFoldTestInitiated', 'GrowthFoldTestFinished',
        'Contamination', 'MycoTestResult', 'FreezerProIDs', 'FlaskMaintenanceStopped', 'InterestingResult', 'Comments',
        'DateIndex'];

    // setup in setupAssayResults
    var _expectedFlaskFields;
    var _expectedGeneratedFlaskFields;
    var _expectedCalculatedFlaskFields;
    var _expectedCalculations;
    var _dailyMeasurements;
    var generateFlaskData;
    var isSuccessfulCalcField;

    // our loan userId
    var _userId;

    // culture adaptation specific results
    var _expectedAdaptFlaskFields = ['PatientID', 'SampleID', 'Scientist', 'Stage', 'Parasitemia', 'Gametocytemia',
        'PatientpRBCs', 'Hematocrit', 'CultureMedia','SerumBatchID', 'AlbumaxBatchID','FoldIncrease1', 'FoldIncrease2',
        'FoldIncrease3', 'AdaptationCriteria', 'Comments'];
    var _expectedAdaptGeneratedFlaskFields = ['MaintenanceDate', 'MaintenanceStopped', 'StartParasitemia1',
        'StartParasitemia2', 'StartParasitemia3', 'FinishParasitemia1', 'FinishParasitemia2', 'FinishParasitemia3',
        'StartDate1', 'FinishDate1', 'AdaptationDate'];
    var _expectedAdaptCalculatedFlaskFields = ['NumDaysFromGrowthTestFinishToAdaptation', 'NumDaysInCulture',
        'NumDaysToAdaptation', 'NumDaysToGrowthTestStart', 'IncreaseTest1', 'IncreaseTest2', 'IncreaseTest3',
        'PassTest1', 'PassTest2', 'PassTest3','SuccessfulAdaptation'];

    // drug selection specific results
    var _expectedSelectFlaskFields = ['PatientID', 'SampleID', 'Scientist', 'AdaptationSampleID', 'FreezerProID',
        'InitialPopulation', 'Compound', 'Concentration', 'CultureMedia','SerumBatchID', 'AlbumaxBatchID',
        'SuperstockBatchID', 'WorkingstockBatchID','RBCBatchID','Control', 'ResistanceProtocol', 'ResistanceNumber',
        'MinimumParasitemia', 'FoldIncrease1', 'FoldIncrease2', 'FoldIncrease3', 'Comments'];

    var _expectedSelectGeneratedFlaskFields = ['MaintenanceDate', 'MaintenanceStopped', 'StartParasitemia1',
        'StartParasitemia2', 'StartParasitemia3', 'FinishParasitemia1', 'FinishParasitemia2', 'FinishParasitemia3',
        'StartDate1', 'FinishDate1', 'ConsecutiveDays'];

    var _expectedSelectCalculatedFlaskFields = ['FirstDayPositiveGrowth', 'FirstDayPositiveResistantPopluation',
        'IncreaseTest1', 'IncreaseTest2', 'IncreaseTest3','PassTest1', 'PassTest2', 'PassTest3',
        'SuccesfulPreliminaryResistanceDays', 'SuccessfulPreliminaryResistanceGrowthFold'];

    var _selectionCompounds = [];

    // stors expected results, initialzed in setupAssayResults
    var _day0Data;
    var _dailyData;
    var _lastDailyUpload;
    var _startTime;

    // test flow control and state
    var _failed = false;
    var _expectedError;
    var _testName;
    var _testNum = 0;

    var _adaptationAssay = "Culture Adaptation";
    var _selectionAssay = "Drug Selection";

    // Each row is a daily measurement.  For example, Patient1Flask2 on 4/20/2013 had a parasitemia valud of 4 %, initialied
    // growth-fold test 2 and finished growth-fold test 1.  The flask was not stopped.
    var _dailyAdaptMeasurements = [
        {id : 'Patient1Flask1', parasitemia : 1, date : '2/20/2013', init : null, finish : null, stop : false },
        {id : 'Patient1Flask2', parasitemia : 2, date : '2/20/2013', init : 1, finish : null, stop : false },
        {id : 'Patient1Flask1', parasitemia : 2, date : '4/20/2013', init : 1, finish : null, stop : false },
        {id : 'Patient1Flask2', parasitemia : 4, date : '4/20/2013', init : 2, finish : 1, stop : false },
        {id : 'Patient1Flask1', parasitemia : 4, date : '7/20/2013', init : null, finish : 1, stop : false },
        {id : 'Patient1Flask2', parasitemia : 17, date :'7/20/2013', init : null, finish : 2, stop : false },
        {id : 'Patient2Flask2', parasitemia : 0.1, date : '2/20/2013', init : 1, finish : 1, stop : false },
        {id : 'Patient2Flask5', parasitemia : 13, date : '2/20/2013', init : null, finish : null, stop : true },
        {id : 'Patient2Flask8', parasitemia : 8, date : '2/20/2013', init : 2, finish : null, stop : false },
        {id : 'Patient2Flask2', parasitemia : 0.1, date : '2/21/2013', init : 2, finish : null, stop : false },
        {id : 'Patient2Flask8', parasitemia : 64, date : '2/21/2013', init : 3, finish : 2, stop : false },
        {id : 'Patient2Flask2', parasitemia : 0, date : '2/22/2013', init : null, finish : 2, stop : false },
        {id : 'Patient2Flask8', parasitemia : 80, date :'2/22/2013', init : null, finish : 3, stop : false }
    ];
    /*
     Initial setup for Day0 data for adaptation flasks is as follows:
     FoldIncrease1: 2
     FoldIncrease2: 4
     FoldIncrease3: 8
     AdaptationCriteria: 2
     A flask will be considered to adapt iff at least two out of three of the growth tests pass.
     A growth test passes if the parasitemia when the tests finishes divided by the parasitemia when
     the test starts is greater than the specified FoldIncrease.  For example, a flask will only pass
     growth test 3 if the (finish parasitemia)/(start parasitemia) > 8.

     For patient 1, test the following scenarios:
     1. can upload fewer flasks in daily update than the experiment has in day 0
     2. start a growth test
     3. flask1 should not adapt even though it passed growth test1 because it is under the adaptation criteria of 2
     4. flask2 should adapt because it passes two growth tests (1 and 2)

     Patient 2: test the following scenarios
     1. ensure parasitemia values of 0 are okay throughout the measuerents and don't blow up the queries (flask2)
     2. ensure that flask maintenance can be stopped (flask5)
     3. ensure that flask 8 does not adapt because we'll have growth test 2 pass byt 3 fail
     */
    var _expectedAdaptCalculations = [{
        SampleID : 'Patient1Flask1',
        MaintenanceStopped : null,
        IncreaseTest1 : 2,
        IncreaseTest2 : 0,
        IncreaseTest3 : 0,
        PassTest1 : 1,
        PassTest2 : 0,
        PassTest3 : 0,
        NumDaysInCulture : 200,
        NumDaysToAdaptation : null,
        NumDaysToGrowthTestStart : 109,
        NumDaysFromGrowthTestFinishToAdaptation : null,
        SuccessfulAdaptation : 'No',
        AdaptationDate : null
    },{
        SampleID : 'Patient1Flask2',
        MaintenanceStopped : null,
        IncreaseTest1 : 2,
        IncreaseTest2 : 4.25,
        IncreaseTest3 : 0,
        PassTest1 : 1,
        PassTest2 : 1,
        PassTest3 : 0,
        NumDaysInCulture : 200,
        NumDaysToAdaptation : 200,
        NumDaysToGrowthTestStart : 50,
        NumDaysFromGrowthTestFinishToAdaptation : 91,
        SuccessfulAdaptation : 'Yes',
        AdaptationDate : '7/20/2013'
    },{
        SampleID : 'Patient2Flask2',
        MaintenanceStopped : null,
        IncreaseTest1 : 1,
        IncreaseTest2 : 0,
        IncreaseTest3 : 0,
        PassTest1 : 0,
        PassTest2 : 0,
        PassTest3 : 0,
        NumDaysInCulture : 43,
        NumDaysToAdaptation : null,
        NumDaysToGrowthTestStart : 41,
        NumDaysFromGrowthTestFinishToAdaptation : null,
        SuccessfulAdaptation : 'No',
        AdaptationDate : null
    },{
        SampleID : 'Patient2Flask5',
        MaintenanceStopped : '2/20/2013',
        IncreaseTest1 : 0,
        IncreaseTest2 : 0,
        IncreaseTest3 : 0,
        PassTest1 : 0,
        PassTest2 : 0,
        PassTest3 : 0,
        NumDaysInCulture : 41,
        NumDaysToAdaptation : null,
        NumDaysToGrowthTestStart : null,
        NumDaysFromGrowthTestFinishToAdaptation : null,
        SuccessfulAdaptation : 'No',
        AdaptationDate : null
    },{
        SampleID : 'Patient2Flask8',
        MaintenanceStopped : null,
        IncreaseTest1 : 0,
        IncreaseTest2 : 8,
        IncreaseTest3 : 1.25,
        PassTest1 : 0,
        PassTest2 : 1,
        PassTest3 : 0,
        NumDaysInCulture : 43,
        NumDaysToAdaptation : null,
        NumDaysToGrowthTestStart : null,
        NumDaysFromGrowthTestFinishToAdaptation : null,
        SuccessfulAdaptation : 'No',
        AdaptationDate : null
    }];

    // Test growth-fold increases just like we did for adaptation.  Add a bunch more days for selection to test
    // for resistance using the consecutive-days protocol for Patient2.  In particular, pay close attention to the
    // daily values for Patient2 flasks.  Flask2 should never successfully resist because it never has 3 consecutive
    // days with a parasitemia value >= .5.  It has 3 overall days, but not consecutive.  Similarly, Flask8 should
    // show resistance because it does have 3 consecutive days even though the last day it has a parasitemia value that
    // drops below .5.
    var _dailySelectMeasurements = [
        {id : 'Patient1Flask1', parasitemia : 1, date : '2/20/2013', init : null, finish : null, stop : false },
        {id : 'Patient1Flask2', parasitemia : .34, date : '2/20/2013', init : 1, finish : null, stop : false },
        {id : 'Patient1Flask1', parasitemia : 2, date : '4/20/2013', init : 1, finish : null, stop : false },
        {id : 'Patient1Flask2', parasitemia :.68, date : '4/20/2013', init : 2, finish : 1, stop : false },
        {id : 'Patient1Flask1', parasitemia : 4, date : '7/20/2013', init : null, finish : 1, stop : false },
        {id : 'Patient1Flask2', parasitemia : 17, date : '7/20/2013', init : null, finish : 2, stop : false },
        {id : 'Patient2Flask2', parasitemia : 0.1, date : '2/20/2013', init : 1, finish : 1, stop : false },
        {id : 'Patient2Flask5', parasitemia : 0.1, date : '2/20/2013', init : null, finish : null, stop : true },
        {id : 'Patient2Flask8', parasitemia : 0.1, date : '2/20/2013', init : 2, finish : null, stop : false },
        {id : 'Patient2Flask2', parasitemia : 0.53, date : '2/21/2013', init : 2, finish : null, stop : false },
        {id : 'Patient2Flask8', parasitemia : 0.53, date : '2/21/2013', init : 3, finish : null, stop : false },
        {id : 'Patient2Flask2', parasitemia : 0.54, date : '2/22/2013', init : null, finish : 2, stop : false },
        {id : 'Patient2Flask8', parasitemia : 0.54, date : '2/22/2013', init : null, finish : 3, stop : false },
        {id : 'Patient2Flask2', parasitemia : 0.49, date : '2/23/2013', init : null, finish : null, stop : false },
        {id : 'Patient2Flask8', parasitemia : 0.55, date : '2/23/2013', init : null, finish : null, stop : false },
        {id : 'Patient2Flask2', parasitemia : 0.51, date : '2/24/2013', init : null, finish : null, stop : false },
        {id : 'Patient2Flask8', parasitemia : 0.49, date : '2/24/2013', init : null, finish : null, stop : false }
    ];

    /*
     Initial setup for Day0 data for slection flasks is as follows:
     FoldIncrease1: 2
     FoldIncrease2: 4
     FoldIncrease3: 8
     ResistanceNumber: 3 if ResistanceProtocol is 'days'
     ResistanceNumber: 2 if ResistanceProtocol is 'growth-fold'
     MinimumParasitemia = 0.5

     Control:
     Patient1Flask2 has a 'Positive' control
     Patient2Flask2 has 'No' control
     all other flasks have 'Negative' control

     Resistance Protocol:
     Patient2Flask2 and Patient2Flask8 have the 'days' protocol
     all other flasks have the 'growth-fold' protocol.

     A flask will be considered to have developled resistance (SuccessfulPreliminaryResistance) in the following cases:
     If the protocol is 'days' then the flask's parasitemia must be > than the miniminm parasitemia specified on day 0
     for at least 3 days.  If the protocol is 'growth-fold' then the calculation is the same as for adaptation.  Namely
     the growth-fold increase for each test must be  greater than the day 0 values and the number of growth-fold tests
     required to pass must be >= to the ResistanceNumber (2 in this case).

     For patient 1, test the following scenarios:
     1. can upload fewer flasks in daily update than the experiment has in day 0
     2. start a growth test
     3. flask1 should not adapt even though it passed growth test1 because it is under the resistance number of 2
     4. flask2 should resist because it passes two growth tests (1 and 2)

     Patient 2: test the following scenarios
     1. ensure parasitemia values of 0 are okay throughout the measuerents and don't blow up the queries (flask2)
     2. ensure that flask maintenance can be stopped (flask5)
     3. ensure that flask 2 does not have resistance because it doesn't have enough consecutve days
     4. ensure that flask 8 does have have resistance because it has enough consecutive days
     5. ensure that neither flask 2 or 8 report that they have passed the growth-fold resistance tests since their
     protocol is days
     */
    var _expectedSelectCalculations = [{
        SampleID : 'Patient1Flask1',
        MaintenanceStopped : null,
        IncreaseTest1 : 2,
        IncreaseTest2 : 0,
        IncreaseTest3 : 0,
        PassTest1 : 1,
        PassTest2 : 0,
        PassTest3 : 0,
        ConsecutiveDays : null, // protocol is growth-fold so this should be null
        SuccessfulPreliminaryResistanceGrowthFold : 'No',
        SuccessfulPreliminaryResistanceDays : null,
        FirstDayPositiveGrowth : null, // Control is negative, so this should be null
        FirstDayPositiveResistantPopulation : null // Control is negative so this should be null
    },{
        SampleID : 'Patient1Flask2',
        MaintenanceStopped : null,
        IncreaseTest1 : 2,
        IncreaseTest2 : 25,
        IncreaseTest3 : 0,
        PassTest1 : 1,
        PassTest2 : 1,
        PassTest3 : 0,
        ConsecutiveDays : null, // protocol is growth-fold so this should be null
        SuccessfulPreliminaryResistanceGrowthFold : 'Yes',
        SuccessfulPreliminaryResistanceDays : null,
        FirstDayPositiveGrowth : '4/20/2013',
        FirstDayPositiveResistantPopulation : null // Control is 'Positive' so this should be null
    },{
        SampleID : 'Patient2Flask2',
        MaintenanceStopped : null,
        IncreaseTest1 : null, // protocol is days so no growth-fold calculations or tests
        IncreaseTest2 : null,
        IncreaseTest3 : null,
        PassTest1 : null,
        PassTest2 : null,
        PassTest3 : null,
        ConsecutiveDays: 1,
        SuccessfulPreliminaryResistanceGrowthFold : null,
        SuccessfulPreliminaryResistanceDays : 'No',
        FirstDayPositiveGrowth : null, // Control is 'No' so this should not be null
        FirstDayPositiveResistantPopulation : '2/21/2013'
    },{
        SampleID : 'Patient2Flask5',
        MaintenanceStopped : '2/20/2013',
        IncreaseTest1 : 0,
        IncreaseTest2 : 0,
        IncreaseTest3 : 0,
        PassTest1 : 0,
        PassTest2 : 0,
        PassTest3 : 0,
        ConsecutiveDays: null, // protocol is growth-fold so this should be null
        SuccessfulPreliminaryResistanceGrowthFold : 'No',
        SuccessfulPreliminaryResistanceDays : null,
        FirstDayPositiveGrowth : null, // Control is negative, so this should be null
        FirstDayPositiveResistantPopulation : null // Control is negative so this should be null
    },{
        SampleID : 'Patient2Flask8',
        MaintenanceStopped : null,
        IncreaseTest1 : null, // protocol is days so no growth-fold calculations or tests
        IncreaseTest2 : null,
        IncreaseTest3 : null,
        PassTest1 : null,
        PassTest2 : null,
        PassTest3 : null,
        ConsecutiveDays: 3,
        SuccessfulPreliminaryResistanceGrowthFold : null,
        SuccessfulPreliminaryResistanceDays : 'Yes',
        FirstDayPositiveGrowth : null, // Control is negative, so this should be null
        FirstDayPositiveResistantPopulation : null // Control is negative so this should be null
    }];

    // setup the test and expected results for the passed in flavor of the tracking assay
    function setupAssayResults(assayName)
    {
        _day0Data = [];
        _dailyData = [];

        if (assayName == _adaptationAssay)
        {
            _assayName = _adaptationAssay;
            _expectedFlaskFields = _expectedAdaptFlaskFields;
            _expectedCalculatedFlaskFields = _expectedAdaptCalculatedFlaskFields;
            _expectedGeneratedFlaskFields = _expectedAdaptGeneratedFlaskFields;
            _expectedCalculations = _expectedAdaptCalculations;
            _dailyMeasurements = _dailyAdaptMeasurements;

            generateFlaskData = generateAdaptFlaskData;
            isSuccessfulCalcField = isAdaptSuccessfulCalcField;
        }
        else
        {
            _assayName = _selectionAssay;
            _expectedFlaskFields = _expectedSelectFlaskFields;
            _expectedCalculatedFlaskFields = _expectedSelectCalculatedFlaskFields;
            _expectedGeneratedFlaskFields = _expectedSelectGeneratedFlaskFields;
            _expectedCalculations = _expectedSelectCalculations;
            _dailyMeasurements = _dailySelectMeasurements;

            generateFlaskData = generateSelectFlaskData;
            isSuccessfulCalcField = isSelectSuccessfulCalcField;
        }
    }

    function switchToSelection()
    {
        setupAssayResults(_selectionAssay);
        runTest();
    }

    function runTest(){
        if (!_userId)
        {
            getUserId();
            return;
        }

        if (_failed)
        {
            var stopTime = new Date().getTime();
            logMessage(_doneMessage + 'Elapsed time:  ' + ((stopTime - _startTime) / 1000) + ' seconds', true);
        }
        else
        {
            if (_testNum > 0) logSuccess();
            if (_testNum >= _tests.length) {
                var stopTime = new Date().getTime();
                logMessage(_doneMessage + 'Elapsed time:  ' + ((stopTime - _startTime) / 1000) + ' seconds');
            }
            else {
                _testName = _tests[_testNum].name;
                _tests[_testNum++].fn.call(this);
            }
        }
    }

    // test getDay0Configs returns expected config objects
    function testDay0Configs()
    {
        LABKEY.page = createDummyTrackingAssayPage(_assayName, _assayId);
        LABKEY.icemr.tracking.getDay0Configs(Day0ConfigsReady);
    }

    function Day0ConfigsReady(runConfigs, flaskConfigs)
    {
        if (!verifyConfig(_expectedRunFields, runConfigs))
            logFailure("runConfigs were not as expected");

        if (!verifyConfig(_expectedFlaskFields, flaskConfigs))
            logFailure("flaskConfigs were not as expected");

        // verify that none of the generated flask fields are in the flaskConfigs
        for (var i = 0; i < _expectedGeneratedFlaskFields; i++)
        {
            if (LABKEY.icemr.isNameInSet(_expectedGeneratedFlaskFields[i], flaskConfigs))
            {
                logFailure("flaskConfigs should not contain generated-only fields");
                break;
            }
        }
        runTest();
    }

    // test createExperiment and createFlask return expected blank objects
    function testDay0Objects()
    {
        if (!verifyObject(LABKEY.icemr.tracking.createExperiment(), _expectedRunFields))
            logFailure("invalid template experiment object returned");

        if (!verifyFlask(LABKEY.icemr.tracking.createFlask()))
            logFailure("invalid template flask object returned");

        // before running the next test get the
        // assay id of the adaptation assay so that
        // we can create a new batch
        LABKEY.Assay.getByName({
            name: _assayName,
            success: AssayIdReady
        });
    }

    function AssayIdReady(assays)
    {
        _assayId = assays[0].id;
        runTest();
    }

    function testInvalidDay0UploadNoFlasks()
    {
        _expectedError = LABKEY.icemr.tracking.errDay0Title + ': ' + LABKEY.icemr.tracking.errDay0NoFlasksDefined;
        LABKEY.icemr.tracking.saveDay0(LABKEY.icemr.tracking.createExperiment(), null, Day0UploadSuccess, VerifyFailure);
    }

    function testInvalidDay0UploadZeroFlasks()
    {
        var flasks = [];
        _expectedError = LABKEY.icemr.tracking.errDay0Title + ': ' + LABKEY.icemr.tracking.errDay0NoFlasksDefined;
        LABKEY.icemr.tracking.saveDay0(LABKEY.icemr.tracking.createExperiment(), flasks, Day0UploadSuccess, VerifyFailure);
    }

    function testDay0Upload1()
    {
        genAndUploadDay0Data("1/1/2013", 1, 5, Day0UploadSuccess, VerifyFailure);
    }

    function testDay0Upload2()
    {
        genAndUploadDay0Data("1/10/2013", 2, 10, Day0UploadSuccess,VerifyFailure);
    }

    function Day0UploadSuccess(result, response)
    {
        // the latest result is the most recently stored value
        if (!validateDay0Data(_day0Data[_day0Data.length -1], result))
            logFailure("Run or material input data wasn't stored correctly");

        runTest();
    }

    function testDay0Results()
    {
        // verify that our calculated queries have the right information
        // even with no measurments (daily maintenance tasks)
        LABKEY.Query.selectRows({
            schemaName : 'assay.Tracking.' + _assayName,
            queryName  : LABKEY.icemr.tracking.interface.getCalcQuery(),
            success: Day0ResultsSuccess
        })
    }

    function getTotalFlasks()
    {
        var totalFlasks = 0;
        for (var i = 0; i < _day0Data.length; i++)
            totalFlasks += _day0Data[i].flasks.length;

        return totalFlasks;
    }

    function Day0ResultsSuccess(data, response, options)
    {
        if (data.rowCount != getTotalFlasks())
            logFailure("incorrect number of flasks returned for day 0 calculated query results");

        for (var i = 0; i < data.rows.length; i++)
            verifyFlaskResult(data.rows[i]);  // this fn will log his own failures if they occur

        runTest();
    }

    function testDailyConfigs()
    {
        LABKEY.icemr.tracking.getFieldConfigs(LABKEY.page.assay.name, DailyConfigsReady)
    }

    function DailyConfigsReady(runConfigs, resultConfigs)
    {
        if (!verifyConfig(_expectedRunFields, runConfigs))
            logFailure("runConfigs were not as expected");

        if (!verifyConfig(_expectedDailyFields, resultConfigs))
            logFailure("resultConfigs were not as expected");

        runTest();
    }

    // test createExperiment and createFlask return
    // expected blank objects
    function testDailyObjects()
    {
        if (!verifyObject(LABKEY.icemr.tracking.createDaily(), _expectedDailyFields))
            logFailure("invalid template daily object returned");

        runTest();
    }

    function testInvalidDailyUploadNoResults()
    {
        var results = [];
        _expectedError = LABKEY.icemr.tracking.errDailyTitle + ': ' + LABKEY.icemr.tracking.errDailyNoResults;
        LABKEY.icemr.tracking.saveDaily(results, DailyUploadSuccess, VerifyFailure);
    }

    function testInvalidDailyUploadExperiment()
    {
        var results = [];
        var exp = {
            ExperimentID : 'bogus'
        };

        results.push(makeDailyResultObject(exp, LABKEY.icemr.tracking.createDaily()));
        _expectedError = LABKEY.icemr.tracking.errDailyTitle + ': ' +
                LABKEY.icemr.tracking.errDailyInvalidExperiment + 'bogus';
        LABKEY.icemr.tracking.saveDaily(results, DailyUploadSuccess, VerifyFailure);
    }

    function testTrackingRunDataPatient1()
    {
        testTrackingRunData("Patient1");
    }

    function testTrackingRunDataPatient2()
    {
        testTrackingRunData("Patient2");
    }

    function testTrackingRunDataPatient2()
    {
        testTrackingRunData("Patient2");
    }

    function testTrackingRunDataAll()
    {
        testTrackingRunData("Patient1;Patient2");
    }

    function testTrackingRunData(patients)
    {
        // get the protocolId, batchid, and row id of
        // for our first entered patient.  We need this info to
        // call the gatherRunData API
        LABKEY.Query.selectRows({
            schemaName : 'assay.Tracking.' + _assayName,
            queryName  : 'Runs',
            columns :  ['RowId', 'Batch/RowId', 'Batch/BatchProtocolId/RowId', 'Protocol/Name'],
            filterArray    : [LABKEY.Filter.create("PatientID", patients, LABKEY.Filter.Types.EQUALS_ONE_OF)],
            success : selectTrackingRunSuccess
        });
    }

    function selectTrackingRunSuccess(data, response, options)
    {
        // we are faking out the LABKEY.icemr.tracking layer by setting the experiments here.
        LABKEY.icemr.tracking.experiments = data.rows;
        LABKEY.icemr.tracking.getAllRunData(trackingRunDataSuccess)
    }

    function trackingRunDataSuccess(batches)
    {
        if (!validateExperimentDatas(batches))
            logFailure("Experiment data didn't match the run data");

        runTest();
    }

    function testInvalidDailyUploadTooManyFlasks()
    {
        var results = [];
        var numFlasks = _day0Data[0].flasks.length;
        var flasks = [];
        var exp = findExperimentInDay0Data('Patient1');

        // add 1 more flask than the day 0 data has
        for (var i = 0; i <= numFlasks; i++)
            flasks.push({name : 'blank'});

        results.push(makeDailyResultObject(exp, flasks));

        _expectedError = LABKEY.icemr.tracking.errDailyTitle + ': ' + LABKEY.icemr.tracking.errDailyTooManyFlasks;
        LABKEY.icemr.tracking.saveDaily(results, DailyUploadSuccess, VerifyFailure );
    }

    function testInvalidDailyUploadInvalidFlask()
    {
        var results = [];
        var invalidSample;
        var date = '1/13/13';
        var flasks = [];
        var exp = findExperimentInDay0Data('Patient1');

        for (var i = 0; i < _day0Data[0].flasks.length; i++)
        {
            var flask = _day0Data[0].flasks[i];
            var resultFlask = generateDailyData(flask.SampleID, 2, date, null, null, false);

            // change last flasks sampleId so that it won't be found
            if (i == (_day0Data[0].flasks.length-1))
            {
                resultFlask.SampleID = resultFlask.SampleID + 'unknown';
                invalidSample = resultFlask.SampleID;
            }
            flasks.push(resultFlask);
        }
        results.push(makeDailyResultObject(exp, flasks));
        _expectedError = LABKEY.icemr.tracking.errDailyTitle + ': ' + LABKEY.icemr.tracking.errDailyInvalidFlaskDefined + invalidSample;
        LABKEY.icemr.tracking.saveDaily(results, DailyUploadSuccess, VerifyFailure );
    }


    function testInvalidDailyUploadZeroParasitemia()
    {
        var results = [];
        var exp = findExperimentInDay0Data('Patient1');
        var date = '2/20/2013';
        var flasks = [];

        // we cannot have a parasitemia value of 0 if a growth test is initiated
        _expectedError = LABKEY.icemr.tracking.errDailyTitle + ': ' + LABKEY.icemr.tracking.errDailyInvalidZeroParasitemia + 'Patient1Flask1';
        flasks.push(generateDailyData('Patient1Flask1', 0, date, 3, null, false));
        results.push(makeDailyResultObject(exp,flasks));
        LABKEY.icemr.tracking.saveDaily(results, DailyUploadSuccess, VerifyFailure );
    }

    function testDailyUpload1()
    {
        dailyUpload('Patient1', '2/20/2013');
    }

    function BulkUploadSuccess(result)
    {
        _bulkCounter++;
        if (_bulkCounter > _bulkLimit)
        {
            runTest();
        }
        else
        {
            loadBulkRow();
        }
    }

    function testBulkUpload()
    {
        _bulkCounter = 0;
        loadBulkRow();
    }

    function loadBulkRow()
    {
        var maintDate = new Date();
        maintDate.setDate(maintDate.getDate() + _bulkCounter);
        var results = [];
        var p = _bulkCounter / _bulkLimit;
        results.push(generateDailyData('Patient2Flask2',p, maintDate, null, null, false));
        LABKEY.icemr.tracking.saveDaily(results, BulkUploadSuccess, VerifyFailure);
    }

    function testInvalidDailyUploadMeasurementExists()
    {
        var results = [];
        var flasks = [];
        var exp = findExperimentInDay0Data('Patient1');
        var date = '2/20/2013';
        flasks.push(generateDailyData('Patient1Flask1', 1, date, null, null, false));
        results.push(makeDailyResultObject(exp, flasks));
        _expectedError = LABKEY.icemr.tracking.errDailyTitle + ': ' + LABKEY.icemr.tracking.errDailyInvalidMeasurementDate + 'Patient1Flask1';
        LABKEY.icemr.tracking.saveDaily(results, DailyUploadSuccess, VerifyFailure );
    }

    function testDailyUpload2()
    {
        dailyUpload('Patient1', '4/20/2013');
    }

    // uploads "3" and "4" happen here to test out multi-experiment daily uploads
    function testMultiExperimentUpload()
    {
        var results = [];
        var exp = findExperimentInDay0Data('Patient1');
        var flasks = getFlasksForDailyUpload('Patient1', '7/20/2013');
        results.push(makeDailyResultObject(exp, flasks));
        exp = findExperimentInDay0Data('Patient2');
        flasks = getFlasksForDailyUpload('Patient2', '2/20/2013');
        results.push(makeDailyResultObject(exp, flasks));
        storeDailyData(results);
        LABKEY.icemr.tracking.saveDaily(results, DailyUploadSuccess, VerifyFailure);
    }

    function testDailyUpload5()
    {
        dailyUpload('Patient2', '2/21/2013');
    }

    function testDailyUpload6()
    {
        dailyUpload('Patient2', '2/22/2013');
    }

    function testDailyUpload7()
    {
        dailyUpload('Patient2', '2/23/2013');
    }

    function testDailyUpload8()
    {
        dailyUpload('Patient2', '2/24/2013');
    }

    function testMaintenanceStopped()
    {
        var results = [];
        var flasks = [];
        var exp = findExperimentInDay0Data('Patient2');
        var date = '2/22/2013';
        // start and finish growth test 2 with a value of parasitemia value of 0
        flasks.push(generateDailyData('Patient2Flask5', 13, date, 3, 3, false));
        results.push(makeDailyResultObject(exp, flasks));
        storeDailyData(results);
        _expectedError = LABKEY.icemr.tracking.errDailyTitle + ': ' + LABKEY.icemr.tracking.errDailyInvalidFlaskDefined + 'Patient2Flask5';
        LABKEY.icemr.tracking.saveDaily(results, DailyUploadSuccess, VerifyFailure );
    }

    function testCalculatedResults()
    {
        // verify our calcuations match our expectations
        LABKEY.Query.selectRows({
            schemaName : 'assay.Tracking.' + _assayName,
            queryName  : LABKEY.icemr.tracking.interface.getCalcQuery(),
            success : selectCalculationSuccess
        });
    }

    function selectCalculationSuccess(data, response, options)
    {
        if (data.rowCount != getTotalFlasks())
            logFailure("incorrect number of flasks returned for calculated query results");

        for (var i = 0; i < data.rows.length; i++)
        {
            var row = data.rows[i];
            var found = false;
            for (var j = 0; j < _expectedCalculations.length; j++)
            {
                if (row.SampleID == _expectedCalculations[j].SampleID)
                {
                    if (!verifyCalculations(row, _expectedCalculations[j]))
                        logFailure("calculated query has an incorrect value");
                    found = true;
                    break;
                }
            }

            if (!found)
                verifyFlaskResult(row);
        }

        runTest();
    }

    function testFoldIncreaseCalculator()
    {
        var parameters = {
            start : '4/20/2013', // parasitemia value here is 4
            finish : '7/20/2013', // parasitemia value here is 17
            flaskId : 'Patient1Flask1'
        };

        // verify our calcuations match our expectations
        LABKEY.Query.selectRows({
            schemaName : 'assay.Tracking.' + _assayName,
            queryName  : LABKEY.icemr.tracking.isSelection ? 'select_generic_foldincrease' : 'adapt_generic_foldincrease',
            parameters : parameters,
            success : foldIncreaseCalculatorSuccess
        });
    }

    function testFirstDayPositiveCalculator()
    {
        var parameters = {
            flaskId : 'Patient2Flask8',
            parasitemia : .54
        };

        // verify our calcuations match our expectations
        LABKEY.Query.selectRows({
            schemaName : 'assay.Tracking.' + _assayName,
            queryName  : 'select_generic_firstdaypositive',
            parameters : parameters,
            success : firstDayPositiveCalculatorSuccess
        });
    }

    function foldIncreaseCalculatorSuccess(data, response, options)
    {
        if (data.rowCount != 1)
            logFailure("unexpected row count returned from the generic_foldincrease query");

        var row = data.rows[0];
        if (row['Increase'] != (4/2))
            logFailure("generic_foldncrease calculation did not return the expected increase");

        runTest();
    }

    function firstDayPositiveCalculatorSuccess(data, response, options)
    {
        if (data.rowCount != 1)
            logFailure("unexpected row count returned from the select_generic_firstdaypositive query");

        var row = data.rows[0];
        if (!LABKEY.icemr.compareDate('2/23/2013', row['FirstDayPositive']))
            logFailure("select_generic_firstdaypositive calculation did not return the expected date");

        runTest();
    }

    function testNumDaysCalculator()
    {
        var parameters = {
            start : '4/20/2013',
            finish : '7/20/2013'
        };

        // verify our calcuations match our expectations
        LABKEY.Query.selectRows({
            schemaName : 'assay.Tracking.' + _assayName,
            queryName  : 'generic_numDays',
            parameters : parameters,
            success : NumDaysCalculatorSuccess
        });
    }

    function testCompounds()
    {
        LABKEY.Query.selectRows({
            schemaName : "icemr",
            queryName : "lk_compound",
            success : compoundsSuccess
        });
    }

    function compoundsSuccess(data, response, options)
    {
        if (data.columnModel.length !=1)
            logFailure("unexpected column count returned from the lk_compound table");
        if (data.rowCount != 5)
            logFailure("unexpected row count returned from the lk_compound table");

        for (var i = 0; i < data.rows.length; i++)
        {
            var row = data.rows[i];
            _selectionCompounds.push(row['compound']);
        }

        runTest();
    }

    function NumDaysCalculatorSuccess(data, response, options)
    {
        if (data.columnModel.length !=1)
            logFailure("unexpected column count returned from the generic_numdays query");

        if (data.rowCount != 1)
            logFailure("unexpected row count returned from the generic_numdays query");

        var row = data.rows[0];
        // sql server returns a -91, postgres returns 91 for the
        // same order of arguments for timestampdiff fn.
        if (row['NumDays'] != 91 && row['NumDays'] != -91)
            logFailure("generic_numdays calculation did not return the expected day count");

        runTest();
    }


    // issue 16955
    // note that the calculations would be off if bug 16955 was not fixed
    // this serves as a regression test to ensure that if we send in a property object of size 0 in
    // saveBatch for a run's input materials that we don't blow away existing flask properties.
    function verifyCalculations(a, b)
    {
        for (key in b)
        {
            if (key == 'MaintenanceStopped' || key == 'AdaptationDate' || key == 'FirstDayPositiveGrowth' ||
                key == 'FirstDayPositiveResistantPopulation')
            {
                if (!LABKEY.icemr.compareDate(a[key], b[key]))
                    return false;
            }
            else
            if (a[key] != b[key])
                return false;
        }

        return true;
    }

    function dailyUpload(patient, date)
    {
        var results = [];
        var exp = findExperimentInDay0Data(patient);
        var flasks = getFlasksForDailyUpload(patient, date);
        results.push(makeDailyResultObject(exp, flasks));
        storeDailyData(results);
        LABKEY.icemr.tracking.saveDaily(results, DailyUploadSuccess, VerifyFailure);
    }

    function getFlasksForDailyUpload(patient, date)
    {
        var flasks = [];
        for (var i = 0; i < _dailyMeasurements.length; i++)
        {
            var d = _dailyMeasurements[i];
            if (isDailyMeasurementApplicable(patient, date, d))
                flasks.push(generateDailyData(d['id'],d['parasitemia'],d['date'],d['init'],d['finish'], d['stop']));
        }

        return flasks;
    }

    function isDailyMeasurementApplicable(patient, date, measurement)
    {
        var p = measurement['id'].substring(0, 'PatientN'.length);
        var d1 = new Date(date);
        var d2 = new Date(measurement['date']);
        return (p == patient && d1.getTime() == d2.getTime())
    }

    function DailyUploadSuccess(batches)
    {
        if (batches.length != _lastDailyUpload.length)
            logFailure("incorrect number of batches saved");

        for (var i = 0; i < batches.length; i++)
        {
            validateDailyData(batches[i]);
            validateFlaskUpdates(batches[i]);
        }
        runTest();
    }

    function VerifyFailure(response)
    {
        if (response.exception !=  _expectedError)
        {
            logFailure(" expected [" + _expectedError + "] reported [" + response.exception + "]");
        }

        runTest();
    }

    function verifyFlaskResult(flask)
    {
        // verify that Day0 data is correct
        var expectedFlask = findFlaskInDay0Data(flask.SampleID);
        for (key in expectedFlask)
        {
            if (flask[key] != expectedFlask[key])
            {
                logFailure("Day0 flask result does not have the uploaded result");
                return false;
            }
        }

        // verify that added calculated columns are present and
        // all 0 or null (except for SuccessfulAdaptation or SuccessfulPreliminaryResistanceGrowthFold which should
        // be "No")
        for (var i = 0; i < _expectedCalculatedFlaskFields.length; i++)
        {
            var calcField = _expectedCalculatedFlaskFields[i];
            if (isSuccessfulCalcField(flask, calcField))
            {
                if (flask[calcField] != 'No')
                {
                    logFailure("Day0 flask result " + calcField + " is not No.");
                    return false;
                }
                continue;
            }

            var val = flask[_expectedCalculatedFlaskFields[i]];
            if (val != null && val != 0)
            {
                logFailure("Day0 flask result has an incorrect non-zero/null calculated column.");
            }
        }

        return true;
    }

    function isAdaptSuccessfulCalcField(flask, calcField)
    {
        if (calcField == 'SuccessfulAdaptation')
            return true;

        return false;
    }

    // selection flask has a different 'successful' column depending
    // on the 'resistance protocol'
    function isSelectSuccessfulCalcField(flask, calcField)
    {
        if ((flask['ResistanceProtocol'] == 'days') &&
             calcField == 'SuccessfulPreliminaryResistanceDays')
            return true;

        if ((flask['ResistanceProtocol'] == 'growth-fold') &&
             calcField == 'SuccessfulPreliminaryResistanceGrowthFold')
            return true;

        return false;
    }

    function validateDailyData(batch)
    {
        var run = batch.runs[0];
        var expId = run.properties[LABKEY.icemr.tracking.experiment];
        var result = findResultInDailyDatas(expId);
        if (!result || !result.flasks)
        {
            logFailure("invalid batch doesn't match daily data saved");
            return false;
        }

        var flasks = result.flasks;
        if (flasks.length != run.dataRows.length)
        {
            logFailure("incorrect number of daily result rows saved");
            return false;
        }

        for (var i = 0; i < run.dataRows.length; i++)
        {
            var row = run.dataRows[i];
            if (!validateDailyDataRow(findFlaskInDailyData(flasks, row.SampleID, row.MeasurementDate), row))
                return false;
        }

        return true;
    }

    function storeDailyData(results)
    {
        // add to the flasks of the correct experiment
        // if not stored already, then add a top level {exp, flasks} object
        for (var i = 0; i < results.length; i++)
        {
            var result = results[i];
            var storedResult = findResultInDailyDatas(result[LABKEY.icemr.tracking.experiment]);
            if (storedResult != null) {
                for (var j = 0; j < result.flasks.length; j++) {
                    storedResult.flasks.push(result.flasks[j]);
                }
            }
            else {
                _dailyData.push(result);
            }
        }

        // remember out last upload
        _lastDailyUpload = results;
    }

    function storeDay0Data(exp, flasks)
    {
        var day0Data = {};
        day0Data.exp = exp;
        day0Data.flasks = flasks;
        _day0Data.push(day0Data);
    }

    function validateDay0Data(expected, batch)
    {
        var run = batch.runs[0];
        if (validateExperimentData(expected.exp, run.properties)) {
            if(validateFlaskData(expected.flasks, run.materialInputs)) {
                return true;
            }
        }

        return false;
    }

    function validateDailyDataRow(expected, row)
    {
        for (key in expected)
        {
            if (key == 'MeasurementDate')
            {
                if (!LABKEY.icemr.compareDate(expected[key], row[key]))
                    return false;
            }
            else
            if (expected[key] != row[key])
                return false;
        }

        return true;
    }

    // issue 16960, verify the role property of an inputMaterial is
    // roundtripped properly
    function verifyRole(input)
    {
        // the role should be something like "Flask N"
        // if we remoev the space then we should find this role in the
        // name of the input
        return (input.name.search(input.role.replace(' ', '')) != -1);
    }

    function validateFlaskUpdates(batch)
    {
        var run = batch.runs[0];
        var inputs = run.materialInputs;
        var exp = run.properties[LABKEY.icemr.tracking.experiment];
        var dailyResult = findResultInDailyDatas(exp);
        var flasks = dailyResult.flasks;

        for (var i = 0; i < inputs.length; i++)
        {
            if (!verifyRole(inputs[i]))
                logFailure("The input material doesn't have the correct role property");

            // this is the updated flask data for the batch we just uploaded
            var updated = inputs[i].properties;
            // this is the flask as it looked at day0 upload time
            var day0 = findFlaskInDay0Data(updated.SampleID);
            // this is the daily result we just uploaded
            var flask = findFlaskInDailyData(flasks, updated.SampleID, updated.MaintenanceDate);

            if (!day0)
                logFailure("updated a flask that was not found in day 0 data");

            if (!flask)
            {
                // this just means that we didn't update the flask during this daily update so it
                // should have same properties as the day0 upload
                if (!validateFlask(day0, updated))
                    logFailure("updated a flask that was not part of the daily result");
            }
            else
            {
                // verify that flask fields were updated correctly
                var p = flask['Parasitemia'];
                var d = flask['MeasurementDate'];

                // verify that we have updated the flask as expected from the result data
                if (!LABKEY.icemr.compareDate(d, updated['MaintenanceDate']))
                    logFailure("flask does not have the correct updated MaintenanceDate");

                validateGrowthTestData(p, d, flask['GrowthFoldTestInitiated'], true, updated);
                validateGrowthTestData(p, d, flask['GrowthFoldTestFinished'], false, updated);

                if (flask['FlaskMaintenanceStopped'])
                    if (!LABKEY.icemr.compareDate(d, updated['MaintenanceStopped']))
                        logFailure("flask does not have the correct MaintenanceStopped date");
            }
        }
    }

    function validateGrowthTestData(p, d, num, start, updated)
    {
        // no growth test
        if (null == num)
            return true;

        // we save off the dates for the first growthtest only
        if (1 == num)
        {
            if (start)
            {
                if (!LABKEY.icemr.compareDate(d, updated['StartDate1']))
                    logFailure("flask did not update StartDate1");
            }
            else
            {
                if (!LABKEY.icemr.compareDate(d, updated['FinishDate1']))
                    logFailure("flask did not update FinishDate1");
            }
        }

        var test = start ? 'StartParasitemia' : 'FinishParasitemia';
        test = test + num;
        if (p != updated[test])
            logFailure("flask did not update " + test);
    }

    // used to validate daily results which may include multiple experiments
    function validateExperimentDatas(batches)
    {
        for (var i = 0; i < batches.length; i++) {
            var batch = batches[i];
            var run = batch.runs[0];
            var exp = findExperimentInDay0Data(run.properties['PatientID']);
            if (!validateExperimentData(exp, run.properties))
                return false;
        }

        return true;
    }

    // used to validate day 0 results which only includes a single experiment
    function validateExperimentData(expected, result)
    {
        // make sure that all the results in the experiment are ones that we have day0 data for
        if (expected['ExperimentID'] == result['ExperimentID'])
        {
            if (expected['PatientID'] == result['PatientID'])
            {
                if (LABKEY.icemr.compareDate(expected['StartDate'], result['StartDate']))
                    return true;

                logMessage("StartDate not equal (expected, result): " + expected['StartDate'] + ", " + result['StartDate']);
            }
            else
            {
                logMessage("PatientID not equal (expected, result): " + expected['PatientID'] + ", " + result['PatientID']);
            }
        }
        else
        {
            logMessage("ExperimentID not equal (expected, result): " + expected['ExperimentID'] + ", " + result['ExperimentID']);
        }

        return false;
    }

    function validateFlaskData(expected, result)
    {
        if (expected.length == result.length)
        {
            for (var i = 0; i < expected.length; i++)
            {
                var a = expected[i];
                // flask order may be different - this is ok
                var b = findFlaskInInputs(a.SampleID, result);
                if (!validateFlask(a,b))
                        return false;
            }
            return true;
        }
        else
        {
            logMessage("Flask properties length are not equal (expected, result): " + expected.length + ", " + "result.length");
        }

        return false;
    }

    function validateFlask(a, b)
    {
        for (key in b)
        {
            if (a[key] != b[key])
            {
                logFailure(key + " : " + a[key] + "!= to" + b[key]);
                return false;
            }
        }

        return true;
    }

    function findResultInDailyDatas(expId)
    {
        for (var i = 0; i < _dailyData.length; i++)
        {
            if (_dailyData[i][LABKEY.icemr.tracking.experiment] == expId)
                return _dailyData[i];
        }

        return null;
    }

    function findFlaskInDailyData(flasks, sampleId, measurementDate)
    {
        var t = new Date(measurementDate).getTime();

        for (var i = 0; i < flasks.length; i++)
        {
            if (flasks[i].SampleID == sampleId &&
                LABKEY.icemr.compareDate(measurementDate, flasks[i].MeasurementDate))
                return flasks[i];
        }
    }

    function findExperimentInDay0Data(patientId)
    {
        for (var i = 0; i < _day0Data.length; i++)
            if (_day0Data[i].exp.PatientID == patientId)
                return _day0Data[i].exp;
    }
    function findFlaskInDay0Data(sampleId)
    {
        for (var i = 0; i < _day0Data.length; i++)
        {
            var day0 = _day0Data[i];
            for (var j = 0; j < day0.flasks.length; j++)
            {
                if (day0.flasks[j].SampleID == sampleId)
                    return day0.flasks[j];
            }
        }

        return null;
    }

    function findFlaskInInputs(sampleId, inputs)
    {
        var flask = null;
        for (var i = 0; i < inputs.length; i++)
        {
            if (inputs[i].properties.SampleID == sampleId)
            {
                flask = inputs[i].properties;
                break;
            }
        }

        return flask;
    }

    function genAndUploadDay0Data(startDate, expNum, numFlasks, success, failure)
    {
        var exp = generateExperimentData(startDate, expNum);
        var flasks = [];
        for (var i = 0; i < numFlasks; i++)
            flasks.push(generateFlaskData(exp.PatientID,exp.PatientID + 'Flask' + (i+1)));

        // provide a LABKEY page and batch object
        // since these are usually provided in the context
        // of the upload views and the uploadhelper requires it
        LABKEY.page = createDummyTrackingAssayPage(_assayName, _assayId);
        storeDay0Data(exp, flasks);
        LABKEY.icemr.tracking.saveDay0(exp, flasks, success, failure);
    }

    function generateDailyData(id, parasitemia, date, init, finish, stop)
    {
        var dailyResult = LABKEY.icemr.tracking.createDaily();
        dailyResult['Scientist'] = _userId;
        dailyResult['SampleID'] = id;  // flask id
        dailyResult['Stage'] = LABKEY.icemr.tracking.stageOptions[Math.floor(Math.random()*LABKEY.icemr.tracking.stageOptions.length)][0];
        dailyResult['Parasitemia'] = parasitemia;
        dailyResult['Gametocytemia'] = Math.floor(Math.random() * 100);
        // if we start validating then we can only have serum or albumax batch id depending on the
        // culture media of the flask (day 0 info)
        dailyResult['SerumBatchID'] = "22";
        dailyResult['AlbumaxBatchID'] = "33";
        dailyResult['MeasurementDate'] = date || new Date();
        dailyResult['Removed'] = Math.floor(Math.random() * 100);
        dailyResult['RBCBatchID'] = "44";
        dailyResult['GrowthFoldTestInitiated'] = init;
        dailyResult['GrowthFoldTestFinished'] = finish;
        dailyResult['Contamination'] = false;
        dailyResult['MycoTestResult'] = "true";
        dailyResult['FlaskMaintenanceStopped'] = stop || false;
        dailyResult['InterestingResult'] = true;
        dailyResult['FreezerProIDs'] = "10 20 3a 4b";
        dailyResult['Comments'] = "this is my comment for the daily maintenace of: " + dailyResult['SampleID'];
        return dailyResult;
    }


    function generateExperimentData(start, num)
    {
        var exp = LABKEY.icemr.tracking.createExperiment();
        exp.ExperimentID = "Experiment" + num;
        exp.StartDate = start;
        exp.PatientID = "Patient" + num;
        return exp;
    }

    function generateBaseFlaskData(patientId, sampleId, flask)
    {
        flask['PatientID'] = patientId;
        flask['SampleID'] =  sampleId;
        flask['Scientist'] = _userId;
        flask['CultureMedia'] = LABKEY.icemr.tracking.cultureMediaOptions[Math.floor(Math.random()*LABKEY.icemr.tracking.cultureMediaOptions.length)][0];
        if (flask['CultureMedia'] == 'serum')
            flask['SerumBatchID'] = 1;
        else
            flask['AlbumaxBatchID'] = 1;
        flask['FoldIncrease1'] = 2;
        flask['FoldIncrease2'] = 4;
        flask['FoldIncrease3'] = 8;
        flask['Comments'] = "this is a comment for flask " + flask['SampleID'];
    }

    function generateAdaptFlaskData(patientId, sampleId)
    {
        var flask = LABKEY.icemr.tracking.createFlask();
        generateBaseFlaskData(patientId, sampleId, flask);

        flask['Stage'] = LABKEY.icemr.tracking.stageOptions[Math.floor(Math.random()*LABKEY.icemr.tracking.stageOptions.length)][0];
        flask['Parasitemia'] = Math.floor(Math.random() * 100);
        flask['Gametocytemia'] = Math.floor(Math.random() * 100);
        flask['PatientpRBCs'] = LABKEY.icemr.tracking.pRBCOptions[Math.floor(Math.random()*LABKEY.icemr.tracking.pRBCOptions.length)][0];
        flask['Hematocrit'] = Math.floor(Math.random() * 100);
        flask['AdaptationCriteria'] = 2;
        return flask;
    }

    function generateSelectFlaskData(patientId, sampleId)
    {
        var flask = LABKEY.icemr.tracking.createFlask();
        generateBaseFlaskData(patientId, sampleId, flask);
        flask['InitialPopulation'] = 5;
        flask['Compound'] = _selectionCompounds[Math.floor(Math.random() * _selectionCompounds.length)];
        flask['Concentration'] = 3;

        // ensure Patient1Flask2 control is positive.  Control value determins the First Day Positive
        // calculators.  If the Control is 'Positive' the we use First Day for Positive Growth.  If the control
        // is 'No' then we use  First Day Positive for ResistantPopulation
        if ('Patient1Flask2' == sampleId)
            flask['Control'] = 'Positive';
        else if ('Patient2Flask2' == sampleId)
            flask['Control'] = 'No';
        else
            flask['Control'] = 'Negative';

        // Ensure that the protocol for Patient2Flask2 and Patient2Flask8 is days.  The ResistanceProtocl determins
        // the sucessful preliminary resistance (consecutive days or growth-fold)
        if ('Patient2Flask2' == sampleId || 'Patient2Flask8' == sampleId)
            flask['ResistanceProtocol'] = 'days';
        else
            flask['ResistanceProtocol'] = 'growth-fold';

        if (flask['ResistanceProtocol'] == 'days')
            flask['ResistanceNumber'] = 3;
        else
            flask['ResistanceNumber'] = 2;

        flask['MinimumParasitemia'] = 0.5;
        return flask;
    }

    function verifyFlask(flask)
    {
        for (key in flask)
        {
            if (!LABKEY.icemr.isNameInArray(key, _expectedFlaskFields))
                if (!LABKEY.icemr.isNameInArray(key, _expectedGeneratedFlaskFields))
                    return false;
        }

        return true;
    }

    function onUserIdSuccess(data)
    {
        _userId = data.rows[0].UserId;
        runTest();
    }

    function getUserId()
    {
        LABKEY.Query.selectRows({
            schemaName: "core",
            queryName: "users",
            columns: "UserId",
            successCallback : onUserIdSuccess,
            filterArray : [ LABKEY.Filter.create("email", "maverick", LABKEY.Filter.Types.CONTAINS)]
        });
    }

    function verifyObject(obj, set)
    {
        for (key in obj)
        {
            if (!LABKEY.icemr.isNameInArray(key, set))
                return false;
        }

        return true;
    }

    function makeDailyResultObject(exp, flasks) {
        var result = {};
        result[LABKEY.icemr.tracking.experiment] = exp[LABKEY.icemr.tracking.experiment];
        result[LABKEY.icemr.tracking.flasks] = flasks;
        return result;
    }

    function verifyConfig(expected, configs)
    {
        if (expected.length == configs.length)
        {
            for (var i = 0; i < expected.length; i++)
                if (!LABKEY.icemr.isNameInSet(expected[i], configs))
                    return false;
            return true;
        }
        return false;
    }


    function logMessage(message, isError)
    {
        _logHtml += "<div" + (isError ? " class=\"labkey-error\">" : ">") + message + "</div>";
        Ext4.get('log-info').update(_logHtml);
    }

    function logFailure(message) {
        logMessage('FAILED {' + _testName + '}:' + message, true);
        _failed = true;
    }

    function logSuccess(){
        logMessage('PASSED {' + _testName + '}');
    }

    function createDummyTrackingAssayPage(assayName, assayId)
    {
        var batch = new LABKEY.Exp.RunGroup();
        batch.batchProtocolId = assayId;
        var page = {
            assay : {
                id : assayId,
                name : assayName
            },
            batch : batch
        };
        return page;
    }

    function init()
    {
        var btn = new Ext4.Button({
            id: 'test-button',
            renderTo: 'start-test',
            text: 'Start Test',
            handler: function(){
                _startTime = new Date().getTime();
                LABKEY.icemr.initValidators();
                setupAssayResults(_adaptationAssay);
                runTest();
            }
        });
    }

    Ext4.onReady(init);
</script>